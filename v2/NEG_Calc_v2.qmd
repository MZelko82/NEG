---
title: "Exploration Analysis in Elevated Plus Maze"
author: "Matt Zelko"
format: html
---

```{r}
# Load necessary packages
library(dplyr)
library(tidyr)
library(ggplot2)
library(readr)
library(readxl)
library(tidyverse)
library(dbscan)
library(alphahull)
library(concaveman)
library(mgcv)
library(brms)
# library(httpgd) - Optional
# hgd()
# httpgd::hgd_browse()

library(httpgd) - Optional
hgd()
httpgd::hgd_browse()
```

# Data Structure
The trial data files have the following structure that needs special handling:

1. Data Structure:
   - Column headers are in row 37
   - Time series data starts from row 39
   - Zone columns need to be combined:
     - Multiple "In zone" columns for Open arms
     - Multiple "In zone" columns for Closed arms
     - Multiple "In zone" columns for Center zone

2. Processing Requirements:
   - Need to create a nested data structure:
     - Top level: metadata (filename, ID, Group etc)
     - Nested: time series data
   - This structure will allow for easier group operations in subsequent analysis

# Process Data
```{r}
#' Read and clean EPM trial data
#' @param file_path Path to the Excel file containing trial data
#' @return A nested tibble with the following structure:
#'   - filename: Name of the source file
#'   - RatID: Identifier for the rat
#'   - Diet: Diet condition
#'   - Strain: Rat strain
#'   - Treatment: Treatment condition
#'   - data: Nested tibble containing time series data with columns:
#'     * Time: Trial time
#'     * X, Y: Centered coordinates
#'     * InOpen: Binary indicator for open arm position
#'     * InClosed: Binary indicator for closed arm position
#'     * distance: Distance traveled between points
#'     * velocity: Instantaneous velocity
read_and_clean_data <- function(file_path, ...) {  # Add ... to capture additional arguments
  # Check if file exists
  if (!file.exists(file_path)) {
    stop("File does not exist: ", file_path)
  }
  
  # Check file extension
  if (!grepl("\\.xlsx$", file_path)) {
    stop("File must be an Excel (.xlsx) file")
  }
  
  cat("\nProcessing file:", basename(file_path), "\n")
  
  # Safely read metadata
  metadata <- tryCatch({
    # Read specifically column B from rows 32-35
    cat("Reading metadata...\n")
    metadata <- readxl::read_xlsx(file_path, range = "B32:B35", col_names = FALSE)
    if (nrow(metadata) != 4) {
      stop("Metadata rows 32-35 are incomplete or missing")
    }
    
    # Debug output for metadata
    cat("Raw metadata values:\n")
    print(metadata)
    
    # Process the metadata
    metadata <- metadata %>%
      rename(value = 1) %>%  # Rename the column
      mutate(field = c("RatID", "Diet", "Strain", "Treatment")) %>%
      pivot_wider(names_from = field, values_from = value)
    
    cat("Processed metadata:\n")
    print(metadata)
    metadata
    
  }, error = function(e) {
    cat("ERROR reading metadata:", e$message, "\n")
    return(NULL)
  })
  
  if(is.null(metadata)) {
    stop("Failed to read metadata")
  }
  
  # Required column names for time series data
  required_cols <- c(
    "Trial time",
    "X center",
    "Y center",
    "In zone(centre_zone / center-point)",
    "In zone(open_arm_1 / center-point)",
    "In zone(open_arm_2 / center-point)",
    "In zone(closed_arm_1 / center-point)",
    "In zone(closed_arm_2 / center-point)"
  )
  
  # Safely read time series data
  data <- tryCatch({
    cat("Reading time series data...\n")
    # First read the headers to check column names
    headers <- readxl::read_xlsx(file_path, skip = 36, n_max = 1)
    cat("Available columns:\n")
    print(names(headers))
    
    # Read data using the headers we found
    cat("Reading full data...\n")
    data <- readxl::read_xlsx(file_path, 
                             skip = 38,
                             col_names = names(headers),
                             na = c("", "-", "NA"))  # Treat "-" as NA
    
    cat("Rows read:", nrow(data), "\n")
    cat("Initial columns:", paste(names(data), collapse = ", "), "\n")
    
    # Clean the data - replace any non-numeric values with NA and convert to numeric
    data <- data %>%
      mutate(across(c(`Trial time`, `X center`, `Y center`), 
                   ~as.numeric(ifelse(. == "-", NA, .))))
    
    # Check for required columns with more flexible matching
    actual_cols <- names(data)
    missing_cols <- c()
    
    # Check for basic columns with exact matches
    if(!"Trial time" %in% actual_cols) missing_cols <- c(missing_cols, "Trial time")
    if(!"X center" %in% actual_cols) missing_cols <- c(missing_cols, "X center")
    if(!"Y center" %in% actual_cols) missing_cols <- c(missing_cols, "Y center")
    
    # Check for zone columns with exact matches
    open_arm_cols <- c("In zone(open_arm_1 / center-point)", "In zone(open_arm_2 / center-point)")
    closed_arm_cols <- c("In zone(closed_arm_1 / center-point)", "In zone(closed_arm_2 / center-point)")
    
    has_open_arms <- all(open_arm_cols %in% actual_cols)
    has_closed_arms <- all(closed_arm_cols %in% actual_cols)
    
    if(!has_open_arms) missing_cols <- c(missing_cols, "open arm zones")
    if(!has_closed_arms) missing_cols <- c(missing_cols, "closed arm zones")
    
    if (length(missing_cols) > 0) {
      cat("\nActual columns found:\n")
      print(actual_cols)
      stop("Missing required columns: ", paste(missing_cols, collapse = ", "))
    }
    
    # Check for empty dataframe
    if (nrow(data) == 0) {
      stop("No time series data found in file")
    }
    
    cat("Processing zone data...\n")
    # Convert zone columns to numeric (they might be character due to "-" values)
    data <- data %>%
      mutate(across(starts_with("In zone"), ~as.numeric(ifelse(. == "-", 0, .))))
    
    # Create InOpen and InClosed columns
    data <- data %>%
      mutate(
        InOpen = case_when(
          `In zone(open_arm_1 / center-point)` == 1 | `In zone(open_arm_2 / center-point)` == 1 ~ 1,
          TRUE ~ 0
        ),
        InClosed = case_when(
          `In zone(closed_arm_1 / center-point)` == 1 | `In zone(closed_arm_2 / center-point)` == 1 ~ 1,
          TRUE ~ 0
        ),
        InCentre = case_when(
          `In zone(centre_zone / center-point)` == 1 ~ 1,
          TRUE ~ 0
        )
      )
    
    cat("Processing coordinates...\n")
    # Create a single data frame with all necessary columns
    data <- tibble(
      Time = as.numeric(data$`Trial time`),
      X = as.numeric(data$`X center`),
      Y = as.numeric(data$`Y center`),
      InOpen = data$InOpen,
      InClosed = data$InClosed,
      InCentre = data$InCentre
    ) %>%
      # Remove rows where X or Y is NA
      dplyr::filter(!is.na(X), !is.na(Y))
    
    cat("Rows after cleaning:", nrow(data), "\n")
    
    # Check for numeric coordinates
    if (!is.numeric(data$X) || !is.numeric(data$Y)) {
      stop("X and Y coordinates must be numeric")
    }
    
    # Check for valid time values
    if (!is.numeric(data$Time) || any(data$Time < 0, na.rm = TRUE)) {
      stop("Time values must be numeric and non-negative")
    }
    
    # Debug output before shift correction
    cat("\nPreparing for shift correction:\n")
    cat("Number of center zone points:", sum(data$InCentre == 1), "\n")
    cat("Coordinate ranges before correction:\n")
    print(summary(data[c("X", "Y")]))
    
    # Apply center-based shift correction with error handling
    tryCatch({
      cat("\nAttempting center-based shift correction...\n")
      source(paste0(getwd(), "/v2.0/center_shift_correction.R"), local = TRUE)  # Load functions in local environment
      
      # Check if required functions exist
      if (!exists("detect_center_shift") || !exists("apply_center_shift")) {
        stop("Required functions not loaded properly")
      }
      
      # Get number of center points before correction
      n_center_points <- sum(data$InCentre == 1)
      cat("Number of center points found:", n_center_points, "\n")
      
      shift_values <- detect_center_shift(data)
      
      cat("Shift detection results:\n")
      cat("Success:", shift_values$success, "\n")
      if (!shift_values$success) {
        cat("Failure reason:", shift_values$reason, "\n")
        cat("Number of points found:", shift_values$n_points, "\n")
        # Even if shift detection fails, we should still proceed with original coordinates
        data <- data %>%
          mutate(
            x_m = X,
            y_m = Y
          )
      } else {
        cat("X shift:", shift_values$x_shift, "\n")
        cat("Y shift:", shift_values$y_shift, "\n")
        cat("Number of points:", shift_values$n_points, "\n")
        cat("Method:", shift_values$method, "\n")
        if(shift_values$low_confidence) {
          cat("Warning: Low confidence correction\n")
        }
        
        # Apply the correction and update coordinates
        cat("\nApplying coordinate correction...\n")
        data <- apply_center_shift(data, shift_values)
      }
      
      # Verify the corrected coordinates exist
      if (!all(c("x_m", "y_m") %in% names(data))) {
        warning("Coordinate correction incomplete: adding uncorrected coordinates")
        data <- data %>%
          mutate(
            x_m = X,
            y_m = Y
          )
      }
      
      # Ensure all necessary columns are present in the correct order
      data <- data %>%
        select(Time, X, Y, InOpen, InClosed, InCentre, x_m, y_m)
      
      cat("\nFinal data structure:\n")
      print(str(data))
      
    }, error = function(e) {
      cat("\nERROR in shift correction:", conditionMessage(e), "\n")
      # On error, use original coordinates and ensure proper column structure
      data <- data %>%
        mutate(
          x_m = X,
          y_m = Y
        ) %>%
        select(Time, X, Y, InOpen, InClosed, InCentre, x_m, y_m)
      cat("Using original coordinates due to error\n")
      return(data)  # Ensure data is returned even on error
    })
    
    # Verify coordinates are properly named before calculating distance
    if (!all(c("x_m", "y_m") %in% names(data))) {
      stop("Coordinate columns not properly renamed")
    }
    
    # Debug output after coordinate processing
    cat("\nCoordinate ranges after processing:\n")
    print(summary(data[c("x_m", "y_m")]))
    
    # Calculate distance and velocity using the coordinates
    cat("\nCalculating distance and velocity...\n")
    data <- data %>%
      mutate(
        distance = sqrt((x_m - lag(x_m))^2 + (y_m - lag(y_m))^2),
        velocity = distance / (Time - lag(Time))
      )
    
    cat("Final data processing complete\n")
    cat("Final data structure:\n")
    print(str(data))
    data
    
  }, error = function(e) {
    cat("ERROR processing time series data:", e$message, "\n")
    return(NULL)
  })
  
  if(is.null(data)) {
    stop("Failed to process time series data")
  }
  
  # Create nested structure
  result <- tryCatch({
    cat("Creating final nested structure...\n")
    # Debug output
    cat("Data object before nesting:\n")
    print(str(data))
    cat("Metadata object before nesting:\n")
    print(str(metadata))
    
    # Ensure data is a tibble
    data <- as_tibble(data)
    
    # Create nested structure with explicit error checking
    result <- metadata %>%
      mutate(
        filename = basename(file_path),
        data = list(data)  # Explicitly list the data
      )
    
    cat("Final result structure:\n")
    print(str(result))
    result
    
  }, error = function(e) {
    cat("ERROR creating nested structure:", conditionMessage(e), "\n")
    cat("Attempting fallback nesting...\n")
    
    # Fallback nesting attempt
    tryCatch({
      result <- tibble(
        filename = basename(file_path),
        RatID = metadata$RatID,
        Diet = metadata$Diet,
        Strain = metadata$Strain,
        Treatment = metadata$Treatment,
        data = list(data)
      )
      cat("Fallback nesting successful\n")
      result
    }, error = function(e2) {
      cat("CRITICAL ERROR: Fallback nesting failed:", conditionMessage(e2), "\n")
      return(NULL)
    })
  })
  
  if(is.null(result)) {
    stop("Failed to create nested structure")
  }
  
  # Verify the structure is correct
  expected_cols <- c("filename", "RatID", "Diet", "Strain", "Treatment", "data")
  missing_cols <- setdiff(expected_cols, names(result))
  if(length(missing_cols) > 0) {
    stop("Missing columns in final structure: ", paste(missing_cols, collapse = ", "))
  }
  
  return(result)
}
```

# Example usage with error handling
```{r}
trials_data <- read_and_clean_data(paste0(getwd(), "/v2.0/Test/Raw data-#1-Trial     1.xlsx"))

# Example of how to work with the nested data:
# Access metadata directly:
print("Metadata variables:")
glimpse(trials_data)  # Just show all columns directly

# Access time series data:
print("\nTime series data structure:")
glimpse(trials_data$data[[1]])

# Example of working with groups:
print("\nExample grouping by metadata:")
trials_data %>%
  group_by(Treatment, Diet) %>%
  summarise(n_trials = n(), .groups = 'drop') %>%
  print()
```

# Test with no error handling
```{r}
trials_data <- read_and_clean_data(paste0(getwd(), "/Raw/Trial/Raw data-AEC24021-Anxious Strain Study-EPM-Analysis #1-Trial    22.xlsx"))

View(trials_data$data[[1]])
```

# Function to unnest data for analysis if needed
```{r}
unnest_trials <- function(nested_data) {
  nested_data %>%
    unnest(data) %>%
    # Ensure time series data has trial identifiers
    group_by(filename, RatID, Diet, Strain, Treatment)
}
trials_data1_unnested <- unnest_trials(trials_data)
# Plot x and y coordinates for trials_data1_unnested
ggplot(trials_data1_unnested) +
  geom_point(aes(x = x_m, y = y_m, color = as.factor(InOpen))) +
  geom_point(aes(x = X, y = Y), color = "grey") +
  facet_wrap(~filename) +
  theme_minimal() +
  labs(title = "X and Y Coordinates for Trials", x = "X Coordinate", y = "Y Coordinate", color = "In Open")
```

# Load and Examine Trial Data
```{r}
# Debug working directory and paths
cat("Current working directory:", getwd(), "\n")
cat("Looking for Raw/Trial folder in:", paste0(getwd(), "/Raw/Trial"), "\n")

# List all files and folders in current directory
cat("\nContents of current directory:\n")
list.files(getwd(), recursive = FALSE)

# Try both capitalization variants for Raw and Trial
raw_trial_path <- file.path(getwd(), "Raw", "Trial")
RAW_trial_path <- file.path(getwd(), "RAW", "Trial")

# Check which path exists
cat("\nChecking folder variants:\n")
cat("Raw/Trial exists:", dir.exists(raw_trial_path), "\n")
cat("RAW/Trial exists:", dir.exists(RAW_trial_path), "\n")

# Use the correct path if found
data_path <- if(dir.exists(raw_trial_path)) {
  raw_trial_path
} else if(dir.exists(RAW_trial_path)) {
  RAW_trial_path
} else {
  stop("Cannot find Raw/Trial or RAW/Trial directory")
}

# List contents of the data directory
cat("\nContents of data directory:\n")
list.files(data_path, pattern = "\\.xlsx$")

# Load all trial files with corrected path
trial_files <- list.files(data_path, 
                         pattern = "^Raw data-.*\\.xlsx$", 
                         full.names = TRUE)

# Print found files
cat("\nFound", length(trial_files), "trial files:\n")
print(basename(trial_files))

# If files are found, proceed with loading
if(length(trial_files) > 0) {
  cat("\nAttempting to load", length(trial_files), "files...\n")
  
  # Read all trials into nested structure - only catch actual errors
  all_trials <- lapply(trial_files, function(f) {
    cat("\n----------------------------------------\n")
    cat("Processing file:", basename(f), "\n")
    tryCatch({
      read_and_clean_data(f)  # This already includes shift detection and correction
    }, error = function(e) {
      cat("ERROR processing file:", e$message, "\n")
      return(NULL)
    })
  })
  
  # Remove NULL entries before binding (only those that actually errored)
  valid_trials <- !sapply(all_trials, is.null)
  cat("\nSummary of processing:\n")
  cat("Total files attempted:", length(all_trials), "\n")
  cat("Successfully processed:", sum(valid_trials), "\n")
  cat("Failed to process:", sum(!valid_trials), "\n")
  
  all_trials <- all_trials[valid_trials]
  
  # Debug output before binding
  cat("\nNumber of valid trials before binding:", length(all_trials), "\n")
  if(length(all_trials) > 0) {
    cat("First trial columns:", paste(names(all_trials[[1]]), collapse = ", "), "\n")
    cat("First trial classes:", paste(sapply(all_trials[[1]], class), collapse = ", "), "\n")
  }
  
  # Explicitly ensure all trials have the same structure
  expected_cols <- c("filename", "RatID", "Diet", "Strain", "Treatment", "data")
  all_trials <- lapply(all_trials, function(trial) {
    missing_cols <- setdiff(expected_cols, names(trial))
    if(length(missing_cols) > 0) {
      cat("\nWARNING: Trial", trial$filename, "missing columns:", 
          paste(missing_cols, collapse = ", "), "\n")
      cat("Available columns:", paste(names(trial), collapse = ", "), "\n")
      return(NULL)
    }
    return(trial)
  })
  
  # Remove any NULL entries again
  valid_trials <- !sapply(all_trials, is.null)
  cat("\nAfter structure validation:\n")
  cat("Valid trials:", sum(valid_trials), "\n")
  cat("Invalid trials:", sum(!valid_trials), "\n")
  
  all_trials <- all_trials[valid_trials]
  
  # Bind rows with explicit column specification
  if(length(all_trials) > 0) {
    all_trials <- bind_rows(all_trials)
    
    # Debug output after binding
    cat("\nColumns after binding:", paste(names(all_trials), collapse = ", "), "\n")
    cat("Classes after binding:", paste(sapply(all_trials, class), collapse = ", "), "\n")
    
    # Print summary of loaded data
    cat("\nSummary of loaded trials:\n")
    if(all(c("Diet", "Treatment") %in% names(all_trials))) {
      all_trials %>%
        group_by(Diet, Treatment) %>%
        summarise(
          n_trials = n(),
          unique_rats = n_distinct(RatID),
          .groups = 'drop'
        ) %>%
        print()
    } else {
      cat("ERROR: Missing required columns. Available columns:", 
          paste(names(all_trials), collapse = ", "), "\n")
    }
    
    # Example: Look at structure of first trial's data
    cat("\nStructure of first trial's time series data:\n")
    tryCatch({
      first_data <- all_trials$data[[1]]
      if(!is.null(first_data)) {
        print(glimpse(first_data))
      } else {
        cat("WARNING: First trial's data is NULL\n")
      }
    }, error = function(e) {
      cat("ERROR examining first trial's data:", e$message, "\n")
    })
    
    # Save loaded data for use in subsequent chunks
    saveRDS(all_trials, "processed_trials.rds")
  } else {
    stop("No valid trials after checking column structure")
  }
} else {
  stop("No trial files found. Please check file names and path.")
}
```

```{r}
View(all_trials$RatID)
```

# Visualise all trials as a heatmap
```{r}
# Create a heatmap of all trials
all_trials %>%
  unnest(data) %>%
  ggplot(aes(x = x_m, y = y_m, color = as.factor(InOpen))) +
  geom_point() +
  #facet_wrap(~filename) +
  theme_minimal() +
  labs(title = "Heatmap of all trials", x = "Time", y = "Y Coordinate", color = "In Open")
```

# Add unique id for each trial using Diet, Strain and ID
```{r}
all_trials <- all_trials %>%
  mutate(trial_id = paste(Diet, Strain, RatID, sep = "_"))

# Check for duplicates
anyDuplicated(all_trials$trial_id)
```

# Save data to csv and RData file
```{r}
# Unnest data column
all_trials_unnested <- all_trials %>%
  unnest(data)
all_trials_unnested_2 <- all_trials_unnested %>%
  select(-filename)
```

```{r}
# Save all_trials to a csv file
write_csv(all_trials_unnested, paste0(getwd(), "/data/processed/all_trials_processed.csv"))

# Save all environment variables to an RData file
save.image(paste0(getwd(), "/data/processed/NEG_Calc_2_v1.RData"))
```

# Create grids
## Function to create complete arm grids
```{r}
create_complete_arm_grids <- function(data) {
  # Filter data for each area
  open_arms_data <- data %>% 
    filter(InOpen == 1, InCentre == 0) %>%
    filter(!is.na(x_m) & !is.na(y_m))
  
  closed_arms_data <- data %>% 
    filter(InClosed == 1, InCentre == 0) %>%
    filter(!is.na(x_m) & !is.na(y_m))
  
  # Get center zone coordinates to determine where arms start
  center_data <- data %>%
    filter(InCentre == 1) %>%
    filter(!is.na(x_m) & !is.na(y_m))
  
  # Find the boundaries of the center zone
  center_x_min <- min(center_data$x_m)
  center_x_max <- max(center_data$x_m)
  center_y_min <- min(center_data$y_m)
  center_y_max <- max(center_data$y_m)
  
  # For open arms (along y-axis)
  # Create depth bands every 2cm starting from the edge of center zone
  open_positive_depths <- seq(from = center_y_max, 
                            to = max(open_arms_data$y_m), 
                            by = 2)
  open_negative_depths <- seq(from = center_y_min, 
                            to = min(open_arms_data$y_m), 
                            by = -2)
  
  # Create bands for open arms
  open_bands <- bind_rows(
    # Positive y direction bands
    tibble(
      depth_start = head(open_positive_depths, -1),
      depth_end = tail(open_positive_depths, -1),
      x_min = min(open_arms_data$x_m),
      x_max = max(open_arms_data$x_m)
    ),
    # Negative y direction bands
    tibble(
      depth_start = head(open_negative_depths, -1),
      depth_end = tail(open_negative_depths, -1),
      x_min = min(open_arms_data$x_m),
      x_max = max(open_arms_data$x_m)
    )
  ) %>%
    mutate(
      band_id = row_number(),
      grid_type = "open"
    )
  
  # For closed arms (along x-axis)
  # Create depth bands every 2cm starting from the edge of center zone
  closed_positive_depths <- seq(from = center_x_max, 
                              to = max(closed_arms_data$x_m), 
                              by = 2)
  closed_negative_depths <- seq(from = center_x_min, 
                              to = min(closed_arms_data$x_m), 
                              by = -2)
  
  # Create bands for closed arms
  closed_bands <- bind_rows(
    # Positive x direction bands
    tibble(
      depth_start = head(closed_positive_depths, -1),
      depth_end = tail(closed_positive_depths, -1),
      y_min = min(closed_arms_data$y_m),
      y_max = max(closed_arms_data$y_m)
    ),
    # Negative x direction bands
    tibble(
      depth_start = head(closed_negative_depths, -1),
      depth_end = tail(closed_negative_depths, -1),
      y_min = min(closed_arms_data$y_m),
      y_max = max(closed_arms_data$y_m)
    )
  ) %>%
    mutate(
      band_id = row_number(),
      grid_type = "closed"
    )
  
  # Combine all bands
  total_bands <- bind_rows(
    open_bands,
    closed_bands
  )
  
  # Create total grid type (combining open and closed bands)
  total_grid <- bind_rows(
    open_bands %>% select(-grid_type),
    closed_bands %>% select(-grid_type)
  ) %>%
  mutate(grid_type = "total")
  
  # Create nested structure
  grid_data <- bind_rows(
    total_bands,
    total_grid
  ) %>%
  group_by(grid_type) %>%
  nest()
  
  return(grid_data)
}
```

## Create grid by arm type 
```{r}
arm_grids_4 <- create_complete_arm_grids(all_trials_unnested_2)
View(arm_grids_4$data[[1]])
glimpse(arm_grids_4$data[[1]])
View(arm_grids_4)
```

## Plot the grids as 3 separate plots
```{r}
# Plot showing grid bands for each arm type
ggplot() +
  # For open arms (vertical bands)
  geom_rect(data = arm_grids_4$data[[1]], 
            aes(xmin = x_min, xmax = x_max,
                ymin = depth_start, ymax = depth_end),
            fill = "lightblue", color = "darkgrey", alpha = 0.3) +
  # For closed arms (horizontal bands)
  geom_rect(data = arm_grids_4$data[[2]], 
            aes(xmin = depth_start, xmax = depth_end,
                ymin = y_min, ymax = y_max),
            fill = "lightgreen", color = "darkgrey", alpha = 0.3) +
  # Add points to show actual movement data
  geom_point(data = all_trials_unnested_2 %>% filter(InOpen == 1 | InClosed == 1), 
             aes(x = x_m, y = y_m, color = factor(InOpen)), 
             alpha = 0.1, size = 0.5) +
  # Facet by grid type
  coord_equal() +
  scale_color_manual(values = c("red", "blue"), 
                    labels = c("Closed Arm", "Open Arm"),
                    name = "Location") +
  labs(title = "Grid Bands by Arm Type",
       x = "X Position (cm)",
       y = "Y Position (cm)") +
  theme_minimal()
```

```{r}
all_trials %>%
  unnest(data) %>%
  ggplot() +
  geom_point(aes(x = x_m, y = y_m, color = as.factor(InCentre))) +
  geom_tile(data = arm_grids_4$data[[3]], aes(x = x_min, y = y_min, fill = count), alpha = 0.1)+
  theme_minimal()+
  coord_equal()
```

# Make data2 column from data column in all_trials that is a dataframe, not a list
```{r}
all_trials_2 <- all_trials

all_trials_2 <- all_trials_2 %>%
  mutate(data2 = map(data, ~as.data.frame(.)))

# Create x_mr and y_mr columns in data2 column as rounded x_m and y_m columns
all_trials_2 <- all_trials_2 %>%
  mutate(data2 = map(data2, ~mutate(., x_mr = round(x_m), y_mr = round(y_m))))

head(all_trials_2$data2[[1]])
```

# Function to calculate first visits and cumulative percentages
```{r}
calculate_grid_exploration <- function(trial_data, grid_data) {
  # Extract grid coordinates for each type
  grid_types <- grid_data %>%
    unnest(data) %>%
    split(.$grid_type)
  
  # Function to process each grid type
  process_grid_type <- function(trial_df, grid_type_df) {
    # Safety check - ensure we have data
    if (nrow(trial_df) == 0 || nrow(grid_type_df) == 0) {
      return(NULL)
    }
    
    # Get total number of depth bands for percentage calculation
    # Divide by 2 since we have bands in both positive and negative directions
    total_bands <- nrow(grid_type_df) / 2
    
    if (total_bands == 0) {
      return(NULL)
    }
    
    # Create a vector to track visited bands
    visited <- rep(FALSE, nrow(grid_type_df))
    names(visited) <- grid_type_df$band_id
    
    # Process each timepoint
    result <- trial_df %>%
      mutate(
        is_new_visit = map_lgl(seq_len(n()), function(i) {
          x <- x_m[i]
          y <- y_m[i]
          
          # Check which band contains this point
          if (grid_type_df$grid_type[1] == "open") {
            # For open arms, check y-coordinate against depth bands
            band_idx <- which(
              y >= grid_type_df$depth_start & 
              y <= grid_type_df$depth_end &
              x >= grid_type_df$x_min &
              x <= grid_type_df$x_max
            )
          } else if (grid_type_df$grid_type[1] == "closed") {
            # For closed arms, check x-coordinate against depth bands
            band_idx <- which(
              x >= grid_type_df$depth_start & 
              x <= grid_type_df$depth_end &
              y >= grid_type_df$y_min &
              y <= grid_type_df$y_max
            )
          } else {
            # For total, check both open and closed conditions
            band_idx <- which(
              (y >= grid_type_df$depth_start & 
               y <= grid_type_df$depth_end &
               x >= grid_type_df$x_min &
               x <= grid_type_df$x_max) |
              (x >= grid_type_df$depth_start & 
               x <= grid_type_df$depth_end &
               y >= grid_type_df$y_min &
               y <= grid_type_df$y_max)
            )
          }
          
          # If point is in a band and band hasn't been visited
          if (length(band_idx) > 0 && !visited[band_idx]) {
            visited[band_idx] <<- TRUE
            return(TRUE)
          }
          return(FALSE)
        }),
        cumulative_visits = cumsum(is_new_visit),
        exploration_percentage = (cumulative_visits / total_bands) * 100
      )
    
    return(result)
  }
  
  # Process each grid type and combine results
  results <- map(grid_types, function(grid_type_df) {
    result <- process_grid_type(trial_data, grid_type_df)
    if (is.null(result)) {
      # Return empty dataframe with correct structure if processing failed
      return(trial_data %>% 
             mutate(
               coord_key = NA_character_,
               is_new_visit = FALSE,
               cumulative_visits = 0,
               exploration_percentage = 0
             ))
    }
    return(result)
  }) %>%
    bind_rows(.id = "grid_type")
  
  return(results)
}

# Test the function on a single trial first
test_trial <- all_trials_2$data2[[1]]
test_result <- calculate_grid_exploration(test_trial, arm_grids_4)

# If test is successful, apply to all trials
if (!is.null(test_result)) {
  all_trials_3 <- all_trials_2 %>%
    mutate(exploration_data = map(data2, ~calculate_grid_exploration(., arm_grids_4)))
  
  # Print summary of first trial to verify
  cat("First trial summary:\n")
  print(summary(all_trials_3$exploration_data[[1]]$exploration_percentage))
} else {
  stop("Test trial processing failed")
}
```

# Example plot for the first trial
```{r}
glimpse(all_trials_3)
View(all_trials_3$exploration_data[[2]])

# Plot exploration percentage over time for first trial
first_trial_exploration <- all_trials_3$exploration_data[[2]]

ggplot(first_trial_exploration, 
       aes(x = Time, y = exploration_percentage, color = grid_type)) +
  geom_line() +
  theme_minimal() +
  labs(title = "Grid Square Exploration Over Time",
       x = "Time (s)",
       y = "Percentage of Grid Squares Explored",
       color = "Arm Type") +
  ylim(0, 100)
```

# Apply the function to all trials
```{r}
all_trials_4 <- all_trials_3

# Look at head of exploration_data column
View(all_trials_4$exploration_data[[1]])
View(all_trials_4$data[[1]])
```

# Unnest exploration_data column
```{r}
glimpse(all_trials_4)
# Keep RatID, Diet, Strain, exploration_data column
all_trials_4_unnested <- all_trials_4 %>%
  select(RatID, Diet, Strain, exploration_data) %>%
  unnest(exploration_data)

# Look at head of unnested dataframe
head(all_trials_4_unnested)

```

```{r}
# Save entire environment to RData file
save.image(paste0(getwd(), "/data/processed/NEG_Calc_2_v3.RData"))
load(paste0(getwd(), "/data/processed/NEG_Calc_2_v1.RData"))
```

# Create column called RatID2 that is RatID_Diet_Strain
```{r}
all_trials_4_unnested <- all_trials_4_unnested %>%
  mutate(RatID2 = paste(RatID, Diet, Strain, sep = "_"))

glimpse(all_trials_4_unnested)
```

# Plot the exploration percentage for each trial by grid type facetted by Diet and Strain
```{r}
NEG_faceted_plot <- ggplot(all_trials_4_unnested) +
  geom_line(aes(x = Time, y = exploration_percentage, color = grid_type, group =interaction(RatID2, grid_type)),alpha = 0.2) +
  geom_smooth(aes(x = Time, y = exploration_percentage, color = grid_type, group =interaction(Diet, Strain, grid_type)), se = TRUE) +
  facet_grid(Diet ~ Strain) +
  theme_minimal()
NEG_faceted_plot
```

# Save the plot
```{r}
ggsave(NEG_faceted_plot, filename = paste0(getwd(), "/NEG/NEG_faceted_plot.png"), width = 10, height = 10, bg = "white")
```

```{r}
NEG_faceted_plot_2 <- ggplot(all_trials_4_unnested) +
  geom_smooth(aes(x = Time, y = exploration_percentage, color = grid_type, group =interaction(Diet, Strain, grid_type)), se = TRUE) +
  facet_grid(Diet ~ Strain) +
  theme_minimal()
NEG_faceted_plot_2
```

# Save the plot
```{r}
ggsave(NEG_faceted_plot_2, filename = paste0(getwd(), "/NEG/NEG_faceted_plot_2.png"), width = 10, height = 10, bg = "white")
```

# Create summary dataframe of exploration percentage by grid type, Diet, and Strain over time
```{r}
all_trials_4_unnested_summary <- all_trials_4_unnested %>%
  group_by(Diet, Strain, grid_type, Time) %>%
  summarise(mean_exploration_percentage = mean(exploration_percentage), sd_exploration_percentage = sd(exploration_percentage))
```

# Plot the summary dataframe
```{r}
ggplot(all_trials_4_unnested_summary %>% filter(grid_type != "total")) +
  geom_line(aes(x = Time, y = mean_exploration_percentage, color = grid_type, group =interaction(Diet, Strain, grid_type)), alpha = 0.2) +
  geom_ribbon(aes(x = Time, ymin = mean_exploration_percentage - sd_exploration_percentage, ymax = mean_exploration_percentage + sd_exploration_percentage, fill = grid_type), alpha = 0.2) +
  # Rename legend to Arm Type
  scale_color_discrete(name = "Arm Type") +
  scale_fill_discrete(name = "Arm Type") +
  labs(title = "Exploration Percentage by Grid Type, Diet, and Strain over Time",
       x = "Time (s)",
       y = "NEG (%)") +
  facet_grid(Diet ~ Strain) +
  theme_minimal()
```

```{r}
ggplot(all_trials_4_unnested_summary %>% filter(grid_type == "total")) +
  geom_line(aes(x = Time, y = mean_exploration_percentage, color = grid_type, group =interaction(Diet, Strain, grid_type)), alpha = 0.2) +
  geom_ribbon(aes(x = Time, ymin = mean_exploration_percentage - sd_exploration_percentage, ymax = mean_exploration_percentage + sd_exploration_percentage, fill = grid_type), alpha = 0.2) +
  # Rename legend to Arm Type
  scale_color_discrete(name = "Arm Type") +
  scale_fill_discrete(name = "Arm Type") +
  labs(title = "Exploration Percentage by Grid Type, Diet, and Strain over Time",
       x = "Time (s)",
       y = "NEG (%)") +
  facet_grid(Diet ~ Strain) +
  theme_minimal()
```

# Plot grid_type = open for Strain = WKY and separte by Diet
```{r}
ggplot(all_trials_4_unnested_summary %>% filter(grid_type == "open" & Strain == "WKY")) +
  geom_line(aes(x = Time, y = mean_exploration_percentage, color = Diet, group =interaction(Diet, grid_type))) +
  geom_ribbon(aes(x = Time, ymin = mean_exploration_percentage - sd_exploration_percentage, ymax = mean_exploration_percentage + sd_exploration_percentage, group =interaction(Diet, grid_type), fill =interaction(Diet, grid_type)), alpha = 0.2) +
  theme_minimal()
```

# Nest the data by RatID2 and grid_type
```{r}
all_trials_5 <- all_trials_4_unnested %>%
  group_by(RatID2, grid_type) %>%
  nest()
```

# Downsample each dataframe to one row every 5 seconds
```{r}
# Downsample each dataframe to one row every 5 seconds, so create sequence of 5 second intervals
all_trials_5 <- all_trials_5 %>%
  mutate(data2 = map(data, ~filter(., Time %in% seq(0, 300, 5))))
```

# Plot the first 3 dataframes in data2 column
```{r}
View(all_trials_5$RatID2)

ggplot()+
geom_line(data = all_trials_5$data2[[7]], 
aes(x = Time, y = exploration_percentage), color = "red") +
geom_line(data = all_trials_5$data2[[8]], 
aes(x = Time, y = exploration_percentage), color = "green") +
geom_line(data = all_trials_5$data2[[9]], 
aes(x = Time, y = exploration_percentage), color = "blue") +
theme_minimal()
```

# all_trials_6 
```{r}
all_trials_6 <- all_trials_5 %>%
    select(RatID2, grid_type, data2)

# Create open, closed and total dataframes from data2 column
all_trials_6_open <- all_trials_6 %>%
  filter(grid_type == "open") %>%
  unnest(data2)

all_trials_6_closed <- all_trials_6 %>%
  filter(grid_type == "closed") %>%
  unnest(data2)

all_trials_6_total <- all_trials_6 %>%
  filter(grid_type == "total") %>%
  unnest(data2)

# Make Diet and Strain factors for all_trials_6_total, all_trials_6_open and all_trials_6_closed
all_trials_6_total <- all_trials_6_total %>%
  mutate(Diet = as.factor(Diet), Strain = as.factor(Strain), RatID2 = as.factor(RatID2))

all_trials_6_open <- all_trials_6_open %>%
  mutate(Diet = as.factor(Diet), Strain = as.factor(Strain), RatID2 = as.factor(RatID2))

all_trials_6_closed <- all_trials_6_closed %>%
  mutate(Diet = as.factor(Diet), Strain = as.factor(Strain), RatID2 = as.factor(RatID2))

View(all_trials_6_total)
View(all_trials_6_open)
View(all_trials_6_closed)
```

# Modelling
## GAM model
```{r}
# bam model
bam_model_1 <- bam(exploration_percentage ~ Diet * Strain + 
               s(Time, by=interaction(Diet, Strain)),
             data=all_trials_6_total, 
             method="REML")

# Basic model with interaction between Diet and Strain, plus a smooth for time
gam_model_1 <- gam(exploration_percentage ~ Diet * Strain + 
               s(Time, by=interaction(Diet, Strain)) + 
               s(RatID2, bs="re"), 
             data=all_trials_6_total, 
             method="REML")

# Summarize the model
summary(gam_model_1)

# Plot the model
plot(gam_model_1)

```

# Autocorrelation model: Total Maze
```{r}
model_autocorr <- gamm(exploration_percentage ~ Diet * Strain + 
                       s(Time, by=Diet:Strain), 
                      random=list(RatID2=~1),
                      correlation=corAR1(form=~Time|RatID2),
                      data=all_trials_6_total, 
                      method="REML")

View(summary(model_autocorr$lme))
summary(model_autocorr$gam)$dev.expl 
```

```{r}
# Install if needed
install.packages("MuMIn")
library(MuMIn)

# Calculate marginal and conditional RÂ² (fixed effects only vs. fixed+random)
r.squaredGLMM(model_autocorr$lme)
```

```{r}
library(ggplot2)
library(dplyr)
library(mgcv)

# First, create a prediction grid with all combinations of Diet, Strain, and Time
# Use a sequence of Time values that covers your data range
time_seq <- seq(min(all_trials_6_total$Time), max(all_trials_6_total$Time), length.out = 100)

# Get unique combinations of Diet and Strain
diet_strain_combos <- unique(all_trials_6_total[, c("Diet", "Strain")])

# Create prediction grid
pred_grid <- expand.grid(
  Time = time_seq,
  Diet = levels(all_trials_6_total$Diet),
  Strain = levels(all_trials_6_total$Strain)
)

# Make sure the factors are properly defined
pred_grid$Diet <- factor(pred_grid$Diet, levels = levels(all_trials_6_total$Diet))
pred_grid$Strain <- factor(pred_grid$Strain, levels = levels(all_trials_6_total$Strain))
```

# Total model
```{r}
# Create function to plot predictions
plot_predictions <- function(model, pred_grid, grid_type) {
# Generate predictions (excluding random effects)
predictions_total <- predict(model, newdata = pred_grid, se.fit = TRUE)

# Add predictions to the grid
pred_grid$predicted <- predictions_total$fit
pred_grid$se <- predictions_total$se.fit

# Calculate confidence intervals
pred_grid$upper <- pred_grid$predicted + 1.96 * pred_grid$se
pred_grid$lower <- pred_grid$predicted - 1.96 * pred_grid$se

# Create a combined factor for Diet*Strain for easier plotting
pred_grid$Diet_Strain <- interaction(pred_grid$Diet, pred_grid$Strain, sep = ":")

# Create the plot
ggplot(pred_grid, aes(x = Time, y = predicted, color = Diet_Strain)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = Diet_Strain), alpha = 0.2, color = NA) +
  labs(
    title = paste("Predicted Exploration Percentage Over Time by Diet and Strain for", grid_type),
    x = "Time",
    y = paste("Exploration Percentage:",  grid_type),
    color = "Diet:Strain",
    fill = "Diet:Strain"
  ) +
  theme_minimal() +
  scale_color_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1")
}
```

# Plot predictions for total model
```{r}
plot_predictions(model_autocorr$gam, pred_grid, "Total Maze")
```

# Autocorrelation model: Open Arms
```{r}
model_autocorr_op <- gamm(exploration_percentage ~ Diet * Strain + 
                       s(Time, by=Diet:Strain), 
                      random=list(RatID2=~1),
                      correlation=corAR1(form=~Time|RatID2),
                      data=all_trials_6_open, 
                      method="REML")
r.squaredGLMM(model_autocorr_op$lme)
```

```{r}
plot_predictions(model_autocorr_op$gam, pred_grid, "Open Arms")
```

# Autocorrelation model: Closed Arms
```{r}
model_autocorr_cl <- gamm(exploration_percentage ~ Diet * Strain + 
                       s(Time, by=Diet:Strain), 
                      random=list(RatID2=~1),
                      correlation=corAR1(form=~Time|RatID2),
                      data=all_trials_6_closed, 
                      method="REML")
r.squaredGLMM(model_autocorr_cl$lme)
```

```{r}
plot_predictions(model_autocorr_cl$gam, pred_grid, "Closed Arms")
```

```{r}
# Make function to plot pairwise differences
plot_pairwise_differences <- function(model, pred_grid, grid_type) {
# Step 1: Create a prediction grid with all combinations
time_range <- seq(min(pred_grid$Time), max(pred_grid$Time), length.out = 100)
diet_levels <- unique(pred_grid$Diet)
strain_levels <- unique(pred_grid$Strain)

new_grid <- expand.grid(
  Time = time_range,
  Diet = diet_levels,
  Strain = strain_levels
)

# Step 2: Get predictions
predictions <- predict(model, newdata = new_grid, se.fit = TRUE)
new_grid$fit <- predictions$fit
new_grid$se.fit <- predictions$se.fit
new_grid$lower <- new_grid$fit - 1.96 * new_grid$se.fit
new_grid$upper <- new_grid$fit + 1.96 * new_grid$se.fit

# Step 3: Create a Diet:Strain column for easier processing
new_grid$Diet_Strain <- paste(new_grid$Diet, new_grid$Strain, sep = ":")

# Step 4: Reshape data to calculate differences
wide_preds <- new_grid %>%
  select(Time, Diet_Strain, fit, se.fit) %>%
  pivot_wider(
    id_cols = Time,
    names_from = Diet_Strain,
    values_from = c(fit, se.fit)
  )

# Step 5: Calculate pairwise differences
diet_strain_combos <- unique(new_grid$Diet_Strain)
diff_pairs <- combn(diet_strain_combos, 2, simplify = FALSE)

diff_data <- data.frame()

for (pair in diff_pairs) {
  group1 <- pair[1]
  group2 <- pair[2]
  
  # Column names in the wide format
  fit_col1 <- paste0("fit_", group1)
  fit_col2 <- paste0("fit_", group2)
  se_col1 <- paste0("se.fit_", group1)
  se_col2 <- paste0("se.fit_", group2)
  
  # Calculate differences and SE of differences
  temp_data <- wide_preds %>%
    mutate(
      Comparison = paste(group1, "vs", group2),
      Difference = .data[[fit_col1]] - .data[[fit_col2]],
      SE_diff = sqrt(.data[[se_col1]]^2 + .data[[se_col2]]^2),
      Lower = Difference - 1.96 * SE_diff,
      Upper = Difference + 1.96 * SE_diff
    ) %>%
    select(Time, Comparison, Difference, SE_diff, Lower, Upper)
  
  diff_data <- rbind(diff_data, temp_data)
}

# Step 6: Plot the differences
ggplot(diff_data, aes(x = Time, y = Difference, color = Comparison)) +
  geom_line() +
  geom_ribbon(aes(ymin = Lower, ymax = Upper, fill = Comparison), alpha = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 18, linetype = "dashed", color = "darkred") +
  geom_hline(yintercept = -18, linetype = "dashed", color = "darkred") +
  labs(
    title = paste("Pairwise Differences in Exploration Percentage: ", grid_type),
    subtitle = "Between Diet:Strain Combinations",
    y = "Difference in Exploration Percentage",
    x = "Time"
  ) +
  facet_wrap(~Comparison) +
  theme_minimal()
}
```

# Plot pairwise differences
```{r}
closed_arms_pwd <- plot_pairwise_differences(model_autocorr_cl$gam, all_trials_6_closed, "Closed Arms")
closed_arms_pwd

open_arms_pwd <- plot_pairwise_differences(model_autocorr_op$gam, all_trials_6_open, "Open Arms")
open_arms_pwd

total_maze_pwd <- plot_pairwise_differences(model_autocorr$gam, all_trials_6_total, "Total Maze")
total_maze_pwd
```






# Save Rdata
```{r}
save.image(paste0(getwd(), "/data/processed/NEG_Calc_3v1.RData"))
load(paste0(getwd(), "/data/processed/NEG_Calc_3v1.RData"))
```
---
title: "Exploration Analysis in Elevated Plus Maze"
author: "Matt Zelko"
format: html
---


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)
library(ggplot2)
library(readr)
```


```{r}
# Function to read and clean data
read_and_clean_data <- function(file_path) {
  data <- read_csv(file_path)
  
  # Check for missing values and interpolate
  data <- data %>%
    mutate(x = zoo::na.approx(X, na.rm = FALSE),
           y = zoo::na.approx(Y, na.rm = FALSE))
  
  # Calculate the mean of the coordinates
  x_mean <- mean(data$x, na.rm = TRUE)
  y_mean <- mean(data$y, na.rm = TRUE)
  
  # Recentre the coordinates around (0,0)
  data <- data %>%
    mutate(x = round(x - x_mean, 0),
           y = round(y - y_mean, 0))
  
  return(data)
}

# Function to find and label extreme points
label_extreme_points <- function(data) {
  # Calculate the mean of the coordinates
  x_mean <- mean(data$x, na.rm = TRUE)
  y_mean <- mean(data$y, na.rm = TRUE)
  
  # Find the extreme points corresponding to the mean value
  max_y_at_mean_x <- data %>% filter(x == round(x_mean)) %>% slice(which.max(y))
  min_y_at_mean_x <- data %>% filter(x == round(x_mean)) %>% slice(which.min(y))
  max_x_at_mean_y <- data %>% filter(y == round(y_mean)) %>% slice(which.max(x))
  min_x_at_mean_y <- data %>% filter(y == round(y_mean)) %>% slice(which.min(x))
  
  # Combine the extreme points
  extreme_points <- bind_rows(max_y_at_mean_x, min_y_at_mean_x, max_x_at_mean_y, min_x_at_mean_y)
  
  return(extreme_points)
}

# Function to plot data with labeled extreme points
plot_data_with_labels <- function(data, extreme_points) {
  ggplot(data, aes(x, y)) +
    geom_point(aes(color = Time)) +
    geom_point(data = extreme_points, aes(x, y), color = "red", size = 3) +
    geom_text(data = extreme_points, aes(x, y, label = paste0("(", x, ", ", y, ")")), vjust = -1, color = "red") +
    theme_minimal() +
    labs(title = "Recentered Coordinates with Extreme Points Labeled",
         x = "X Coordinate",
         y = "Y Coordinate")
}


data <- read_and_clean_data(paste0(getwd(), "/Raw/XYTest.csv"))
extreme_points <- label_extreme_points(data)
plot <- plot_data_with_labels(data, extreme_points)
print(plot)
```

## Plot X And Y Coordinates to check min and max values

```{r}
ggplot(data, aes(x = Time, y = x, color = Time)) +
  geom_point() +
  theme_minimal()
```

# Enter edge points of the maze grid and Open / Closed Arm planes
```{r}
# Identify edge points based on the plot above (x, y)
  top_left <- c(-1, 41)
  top_right <- c(3, 41)
  bottom_left<- c(-1, -41)
  bottom_right <- c(3, -41)
  left_top <- c(-38,1)
  left_bottom <- c(-38,-3)
  right_top <- c(42,1)
  right_bottom <- c(42,-3)
  
# Arm Planes using Top Left, Top Right, Bottom Left, Bottom Right, Left Top, Left Bottom, Right Top, Right Bottom
  Open_Arm_Plane <- list(top_left, top_right, bottom_left, bottom_right)
  Closed_Arm_Plane <- list(left_top, left_bottom, right_top, right_bottom)
```

```{r}
# Function to create maze grid centered at (0,0) and mask possible squares based on user input
create_maze_grid <- function(data, top_left, top_right, bottom_left, bottom_right, left_top, left_bottom, right_top, right_bottom) {
  # Determine the ranges for the grid
  x_range <- seq(floor(min(data$x)), ceiling(max(data$x)), by = 1)
  y_range <- seq(floor(min(data$y)), ceiling(max(data$y)), by = 1)
  
  # Create the grid
  grid <- expand.grid(x = x_range, y = y_range)
  
  # Create mask for possible squares
  grid <- grid %>%
    mutate(mask = if_else(
      # First condition: vertical arm
      (x >= top_left[1] & x <= top_right[1] & y <= top_left[2] & y >= bottom_left[2]) |
      # Second condition: horizontal arm
      (y >= left_bottom[2] & y <= left_top[2] & x >= left_top[1] & x <= right_top[1]),
      1, 0))
  
  
  # Zero out the center zone if mask is initially 1
  grid <- grid %>%
    mutate(mask = if_else(
      mask == 1 & x >= top_left[1] & x <= top_right[1] & y <= right_top[2] & y >= right_bottom[2], 0, mask))

  return(grid)
}


grid <- create_maze_grid(data, top_left, top_right, bottom_left, bottom_right, left_top, left_bottom, right_top, right_bottom)
```

# Optional: Plot Maze Grid

```{r}
# Plot the maze grid
ggplot(grid, aes(x = x, y = y, fill = as.factor(mask))) +
  geom_tile() +
  theme_minimal()
```

```{r}
# Function to find the first visit to each grid point using the mask
find_first_visits <- function(data, grid) {
  # Calculate the time step approximation
  time_step_approx <- (max(data$Time, na.rm = TRUE) - min(data$Time, na.rm = TRUE)) / nrow(data)
  
  data <- data %>%
    mutate(time_step = round((row_number() - 1) * time_step_approx),2) # Add an approximated time step column
  
  # Round the coordinates to match the grid points
  data <- data %>%
    mutate(x = round(x),
           y = round(y))
  
  # Initialize the first visit matrix
  grid <- grid %>%
    mutate(first_visit = NA)
  
  for (i in 1:nrow(data)) {
    x <- data$x[i]
    y <- data$y[i]
    time_step <- data$time_step[i]
    
    grid_index <- which(grid$x == x & grid$y == y)
    
    if (length(grid_index) == 1 && grid$mask[grid_index] == 1 && is.na(grid$first_visit[grid_index])) {
      grid$first_visit[grid_index] <- time_step
    }
  }
  
  return(grid)
}

first_visits <- find_first_visits(data, grid)
```

# Optional: Plot First Visits
```{r}
# Plot the first visits
ggplot(first_visits, aes(x = x, y = y, fill = first_visit)) +
  geom_tile() +
  theme_minimal()
```

```{r}
# Function to interpolate missing edge squares based on flags and report interpolation stats
interpolate_edges <- function(grid) {
  # Find the edge squares
  edge_x_min <- min(grid$x[grid$mask == 1], na.rm = TRUE)
  edge_x_max <- max(grid$x[grid$mask == 1], na.rm = TRUE)
  edge_y_min <- min(grid$y[grid$mask == 1], na.rm = TRUE)
  edge_y_max <- max(grid$y[grid$mask == 1], na.rm = TRUE)
  
  grid <- grid %>%
    mutate(is_edge = case_when(
      x == edge_x_min | x == edge_x_max ~ TRUE,
      y == edge_y_min | y == edge_y_max ~ TRUE,
      TRUE ~ FALSE
    ))
  
  # Calculate the initial percentage of visited squares
  initial_visited <- sum(!is.na(grid$first_visit) & grid$mask == 1) / sum(grid$mask == 1) * 100
  initial_visited_count <- sum(!is.na(grid$first_visit) & grid$mask == 1)
  
  # Interpolate visits for edge squares
  for (i in 1:nrow(grid)) {
    if (grid$is_edge[i] && is.na(grid$first_visit[i])) {
      x <- grid$x[i]
      y <- grid$y[i]
      
      if (x == edge_x_min && !is.na(grid$first_visit[grid$x == (x + 1) & grid$y == y])) {
        grid$first_visit[i] <- grid$first_visit[grid$x == (x + 1) & grid$y == y]
      } else if (x == edge_x_max && !is.na(grid$first_visit[grid$x == (x - 1) & grid$y == y])) {
        grid$first_visit[i] <- grid$first_visit[grid$x == (x - 1) & grid$y == y]
      } else if (y == edge_y_min && !is.na(grid$first_visit[grid$x == x & grid$y == (y + 1)])) {
        grid$first_visit[i] <- grid$first_visit[grid$x == x & grid$y == (y + 1)]
      } else if (y == edge_y_max && !is.na(grid$first_visit[grid$x == x & grid$y == (y - 1)])) {
        grid$first_visit[i] <- grid$first_visit[grid$x == x & grid$y == (y - 1)]
      }
    }
  }
  
  # Interpolate visits for squares with at least 4 adjacent squares visited
  for (i in 1:nrow(grid)) {
    if (is.na(grid$first_visit[i]) && grid$mask[i] == 1) {
      x <- grid$x[i]
      y <- grid$y[i]
      
      adj_visited <- sum(
        !is.na(grid$first_visit[grid$x == (x + 1) & grid$y == y]),
        !is.na(grid$first_visit[grid$x == (x - 1) & grid$y == y]),
        !is.na(grid$first_visit[grid$x == x & grid$y == (y + 1)]),
        !is.na(grid$first_visit[grid$x == x & grid$y == (y - 1)]),
        na.rm = TRUE
      )
      
      if (adj_visited >= 4) {
        grid$first_visit[i] <- max(
          grid$first_visit[grid$x == (x + 1) & grid$y == y],
          grid$first_visit[grid$x == (x - 1) & grid$y == y],
          grid$first_visit[grid$x == x & grid$y == (y + 1)],
          grid$first_visit[grid$x == x & grid$y == (y - 1)],
          na.rm = TRUE
        )
      }
    }
  }
  
  # Calculate the final percentage of visited squares
  final_visited <- sum(!is.na(grid$first_visit) & grid$mask == 1) / sum(grid$mask == 1) * 100
  final_visited_count <- sum(!is.na(grid$first_visit) & grid$mask == 1)
  
  # Print the results
  cat(sprintf("Initial visited squares: %d (%.2f%%)\n", initial_visited_count, initial_visited))
  cat(sprintf("Final visited squares: %d (%.2f%%)\n", final_visited_count, final_visited))
  cat(sprintf("Additional squares interpolated: %d\n", final_visited_count - initial_visited_count))
  
  return(grid %>% select(-is_edge))
}


interpolated_grid <- interpolate_edges(first_visits)
```

```{r}
# Function to calculate total maze cumulative percentages based on time steps
calculate_cumulative_percentages <- function(grid) {
  # Sort the grid by time step in ascending order
  grid <- grid %>%
    filter(mask == 1) %>%
    arrange(first_visit)
  
  # Total number of squares available
  total_squares <- sum(grid$mask == 1, na.rm = TRUE)
  
 grid <- grid %>%
  mutate(percentage_increase = if_else(!is.na(first_visit), 100 / total_squares, 0))
  
  # Add a column for cumulative percentage
  grid <- grid %>%
    mutate(cumulative_percentage = cumsum(percentage_increase))
  
  return(grid)
}

cumulative_grid.T <- calculate_cumulative_percentages(interpolated_grid)
```

```{r}
# Plot the cumulative percentages over time with a line plot
ggplot(cumulative_grid.T, aes(x = first_visit, y = cumulative_percentage)) +
  geom_line() +
  labs(x = "Time Step", y = "Total Maze NEG (%)", title = "Novel Exploration Growth Over Time for Total Maze") +
  theme_minimal()
```


```{r}
# Function to add OpenMask and ClosedMask to the grid
add_arm_masks <- function(grid, open_arm_plane, closed_arm_plane) {
  open_top_left <- open_arm_plane[[1]]
  open_top_right <- open_arm_plane[[2]]
  open_bottom_left <- open_arm_plane[[3]]
  open_bottom_right <- open_arm_plane[[4]]
  
  closed_left_top <- closed_arm_plane[[1]]
  closed_left_bottom <- closed_arm_plane[[2]]
  closed_right_top <- closed_arm_plane[[3]]
  closed_right_bottom <- closed_arm_plane[[4]]
  
  grid <- grid %>%
    mutate(OpenMask = if_else(x >= open_top_left[1] & x <= open_top_right[1] & mask == 1, 1, 0),
           ClosedMask = if_else(y >= closed_left_bottom[2] & y <= closed_left_top[2] & mask == 1, 1, 0))
  
  return(grid)
}

interpolated_grid_with_masks <- add_arm_masks(interpolated_grid, Open_Arm_Plane, Closed_Arm_Plane)
```

```{r}
interpolated_grid_with_masks.2 <- interpolated_grid_with_masks |> 
  pivot_longer(cols = c(OpenMask, ClosedMask), names_to = "MaskType", values_to = "MaskValue")

# plot the grid with masks
ggplot(interpolated_grid_with_masks.2, aes(x = x, y = y, fill = as.factor(MaskValue))) +
  geom_tile() +
  theme_minimal() +
  facet_wrap(~MaskType) +
  labs(title = "Maze Grid with Arm Masks",
       x = "X Coordinate",
       y = "Y Coordinate")
```

```{r}
# Function to calculate total maze cumulative percentages based on time steps
calculate_cumulative_percentages.Op <- function(grid) {
  # Sort the grid by time step in ascending order
  grid <- grid %>%
    filter(mask == 1 & OpenMask == 1) %>%
    arrange(first_visit)
  
  # Total number of squares available
  total_squares <- sum(grid$mask == 1, na.rm = TRUE)
  
 grid <- grid %>%
  mutate(percentage_increase = if_else(!is.na(first_visit), 100 / total_squares, 0))
  
  # Add a column for cumulative percentage
  grid <- grid %>%
    mutate(cumulative_percentage = cumsum(percentage_increase))
  
  return(grid)
}

cumulative_grid.Op <- calculate_cumulative_percentages.Op(interpolated_grid_with_masks)
```

```{r}
# Plot the cumulative percentages over time with a line plot
ggplot(cumulative_grid.Op, aes(x = first_visit, y = cumulative_percentage)) +
  geom_line() +
  labs(x = "Time Step", y = "Open Arm NEG (%)", title = "Novel Exploration Growth Over Time for Open Arms") +
  theme_minimal()
```

```{r}
# Function to calculate total maze cumulative percentages based on time steps
calculate_cumulative_percentages.Cl <- function(grid) {
  # Sort the grid by time step in ascending order
  grid <- grid %>%
    filter(mask == 1 & ClosedMask == 1) %>%
    arrange(first_visit)
  
  # Total number of squares available
  total_squares <- sum(grid$mask == 1, na.rm = TRUE)
  
 grid <- grid %>%
  mutate(percentage_increase = if_else(!is.na(first_visit), 100 / total_squares, 0))
  
  # Add a column for cumulative percentage
  grid <- grid %>%
    mutate(cumulative_percentage = cumsum(percentage_increase))
  
  return(grid)
}

cumulative_grid.Cl <- calculate_cumulative_percentages.Cl(interpolated_grid_with_masks)
```

```{r}
# Plot the cumulative percentages over time with a line plot
ggplot(cumulative_grid.Cl, aes(x = first_visit, y = cumulative_percentage)) +
  geom_line() +
  labs(x = "Time Step", y = "Closed Arm NEG (%)", title = "Novel Exploration Growth Over Time for Closed Arms") +
  theme_minimal()
```

# Combined Plot All Time Series

```{r}
# Data preparation for labels
max_values <- bind_rows(
  cumulative_grid.T %>% summarize(first_visit = max(first_visit, na.rm = TRUE), cumulative_percentage = max(cumulative_percentage, na.rm = TRUE)) %>% mutate(label = "Total Maze", color = "#6a396e"),
  cumulative_grid.Op %>% summarize(first_visit = max(first_visit, na.rm = TRUE), cumulative_percentage = max(cumulative_percentage, na.rm = TRUE)) %>% mutate(label = "Open Arm", color = "#6796a8"),
  cumulative_grid.Cl %>% summarize(first_visit = max(first_visit, na.rm = TRUE), cumulative_percentage = max(cumulative_percentage, na.rm = TRUE)) %>% mutate(label = "Closed Arm", color = "#b37460")
)

ggplot() +
  geom_line(data = cumulative_grid.T, aes(x = first_visit, y = cumulative_percentage), color = "#6a396e") +
  geom_line(data = cumulative_grid.Op, aes(x = first_visit, y = cumulative_percentage), color = "#6796a8") +
  geom_line(data = cumulative_grid.Cl, aes(x = first_visit, y = cumulative_percentage), color = "#b37460") +
  # Add labels to the lines for better identification
  geom_label(data = max_values, aes(x = first_visit, y = cumulative_percentage, label = label, fill = color), color = "white", hjust = -0.1) +
  scale_fill_identity() +  # Ensure the fill color is used directly from the data
  labs(x = "Time Step", y = "NEG (%)", title = "Novel Exploration Growth Over Time") +
  xlim(0, max(max_values$first_visit + 50))+
  theme_minimal()
```

